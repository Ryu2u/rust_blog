use crate::post::structs::PageInfo;
use crate::utils::time_utils::get_sys_time;
use crate::{info, Exception, Post, R};

use actix_web::{get, post, web, Responder};
use rbatis::RBatis;

use tracing::{instrument, span, Level};
use crate::utils::md_to_html;

/// 文章 接口
/// api_post_add -> 文章添加
/// api_post_get -> 根据id 获取仅供展示的文章 ()
/// api_post_list_page -> 分页获取仅供展示的文章列表
/// api_post_list_page_admin -> 分页获取所有文章列表
/// api_post_list_get_admin -> 根据id获取文章
/// api_post_list_update -> 根据id更新文章
/// api_post_list_del -> 根据id删除文章(逻辑删除)
pub fn post_scope() -> actix_web::Scope {
    actix_web::web::scope("/post")
        .service(api_post_add)
        .service(api_post_get)
        .service(api_post_list_page)
        .service(api_post_list_page_admin)
        .service(api_post_get_admin)
        .service(api_post_update)
        .service(api_post_del)
}

#[instrument]
#[post("/add")]
async fn api_post_add(
    post: web::Json<Post>,
    db: web::Data<RBatis>,
) -> Result<impl Responder, Exception> {
    match check_post(&*db, &*post).await {
        Ok(md_html) => {
            let post = Post::new(
                post.title.clone(),
                post.author.clone(),
                post.original_content.clone(),
                md_html,
                post.format_content.len() as i32,
            );

            match Post::insert(&**db, &post).await {
                Ok(_) => Ok(R::<()>::ok_msg("添加成功!")),
                Err(_) => Err(Exception::BadRequest("add post failed!".to_string())),
            }
        }
        Err(e) => Err(e),
    }
}

#[instrument]
#[post("/page")]
async fn api_post_list_page(
    page_info: web::Json<PageInfo<Post>>,
    db: web::Data<RBatis>,
) -> Result<impl Responder, Exception> {
    post_list_page(page_info, db, false).await
}

#[instrument]
#[post("/admin/list/page")]
async fn api_post_list_page_admin(
    page_info: web::Json<PageInfo<Post>>,
    db: web::Data<RBatis>,
) -> Result<impl Responder, Exception> {
    post_list_page(page_info, db, true).await
}

#[instrument]
#[get("/admin/get/{id}")]
async fn api_post_get_admin(
    id: web::Path<i32>,
    db: web::Data<RBatis>,
) -> Result<impl Responder, Exception> {
    post_get(id, db, true).await
}

#[instrument]
#[get("/get/{id}")]
async fn api_post_get(
    id: web::Path<i32>,
    db: web::Data<RBatis>,
) -> Result<impl Responder, Exception> {
    post_get(id, db, false).await
}

#[instrument]
#[post("/admin/update")]
async fn api_post_update(
    mut post: web::Json<Post>,
    db: web::Data<RBatis>,
) -> Result<impl Responder, Exception> {
    match check_post(&**db, &post).await {
        Err(e) => Err(e),
        Ok(format_str) => {
            if post.id.is_none() {
                return Err(Exception::BadRequest("该文章不存在!".to_string()));
            }

            post.format_content = format_str;
            post.update_time = Some(get_sys_time());

            match Post::update_by_column(&**db, &post, "id").await {
                Ok(_) => Ok(R::<()>::ok_msg("更新成功!")),
                Err(_) => Err(Exception::BadRequest("更新失败，请重试".to_string())),
            }
        }
    }
}

#[instrument]
#[get("/admin/del/{id}")]
async fn api_post_del(id: web::Path<i32>, db: web::Data<RBatis>) -> Result<impl Responder, Exception> {
    // 判断是否存在 -> 置逻辑删除
    let res = Post::select_by_id(&**db, *id).await;
    if res.is_err() {
        return Err(Exception::NotFound);
    }
    let mut vec = res.unwrap();
    if vec.is_empty() {
        return Err(Exception::NotFound);
    }
    let mut post = vec.pop().unwrap();
    post.is_deleted = Some(1);

    if Post::update_by_column(&**db, &post, "id").await.is_err() {
        return Err(Exception::BadRequest("删除失败，请重试!".to_string()));
    }

    Ok(R::<()>::ok_msg("删除成功!"))
}

//////////////////////////////////////////////////////////////////////////////////////////

///
/// 判断post对象是否合法
///
/// db: 数据库对象
/// post: 文章对象
///
async fn check_post(db: &RBatis, post: &Post) -> Result<String, Exception> {
    let _ = span!(Level::DEBUG, "api_post_add");
    info!("{:?}", post);
    if post.author.len() > 100 {
        return Err(Exception::BadRequest("author is too long!".to_string()));
    }

    if let Ok(vec) = Post::select_by_title(db, post.title.clone()).await {
        if !vec.is_empty() {
            return Err(Exception::BadRequest(format!(
                "title -> [{}] is exists",
                post.title.clone()
            )));
        }
    }
    // "format md -> html"
    let md_html = md_to_html(post.original_content.as_str());
    Ok(md_html)
}

///
/// 根据id获取文章
/// page_info: 分页对象
/// db: 数据库对象
/// is_admin: 是否能够获取未展示的文章
///
async fn post_list_page(
    mut page_info: web::Json<PageInfo<Post>>,
    db: web::Data<RBatis>,
    is_admin: bool,
) -> Result<impl Responder, Exception> {
    let page_num = page_info.page_num;
    let page_size = page_info.page_size;
    let limit = (page_num - 1) * page_size;

    let res = if is_admin {
        page_info.total = Post::count_all(&db).await;
        Post::select_page_admin(&**db, limit, page_size).await
    } else {
        page_info.total = Post::count_view(&db).await;
        Post::select_page(&**db, limit, page_size).await
    };
    if let Ok(mut vec) = res {
        vec.iter_mut().for_each(|i| {
            i.format_content = "".to_string();
            i.original_content = "".to_string();
        });
        page_info.list = Some(vec);
        Ok(R::<PageInfo<Post>>::ok_obj(page_info.clone()))
    } else {
        Err(Exception::InternalError)
    }
}

///
/// 根据id获取文章
/// id: 文章id
/// db: 数据库对象
/// is_admin: 是否能够获取未展示的文章
///
async fn post_get(
    id: web::Path<i32>,
    db: web::Data<RBatis>,
    is_admin: bool,
) -> Result<impl Responder, Exception> {
    if let Ok(mut res) = Post::select_by_id(&**db, *id).await {
        if res.is_empty() {
            return Err(Exception::NotFound);
        }
        let mut post = res.pop().unwrap();

        if is_admin {
            return Ok(R::<Post>::ok_obj(post));
        }
        if post.is_view != 1 {
            return Err(Exception::NotFound);
        }

        info!("{:?}", post);
        match post.visits {
            None => {
                post.visits = Some(1);
            }
            Some(mut v) => {
                v += 1;
                post.visits = Some(v);
            }
        }
        if Post::update_by_column(&**db, &post, "id").await.is_err() {
            Err(Exception::BadRequest("update post failed!".to_string()))
        } else {
            Ok(R::<Post>::ok_obj(post))
        }
    } else {
        Err(Exception::InternalError)
    }
}

#[cfg(test)]
mod test {
    use crate::Post;
    use rbatis::RBatis;
    use rbdc_sqlite::SqliteDriver;
    use std::fs::{read_dir, File};

    use std::io::Read;
    use std::path::Path;

    #[tokio::test]
    async fn test_post_add() {
        let path = "E:\\MarkDown";
        // let file = File::open(Path::new(path)).await;
        let res_dir = read_dir(Path::new(path));
        match res_dir {
            Ok(dirs) => {
                for entry in dirs {
                    if let Ok(dir) = entry {
                        let file_type = dir.file_type().unwrap();
                        if file_type.is_dir() {
                            continue;
                        }
                        println!("{:?}", dir.file_name());
                        let mut file = File::open(dir.path()).unwrap();
                        let mut str = String::new();
                        file.read_to_string(&mut str).unwrap();
                        let html = markdown::to_html(&str);
                        println!("{}", html);
                        let title = dir.file_name().to_str().unwrap().to_string();
                        let author = "Ryu2u".to_string();
                        let original_content = str;
                        let format_content = html;
                        let post = Post::new(
                            title.clone(),
                            author.clone(),
                            original_content.clone(),
                            format_content.clone(),
                            original_content.len() as i32,
                        );
                        let rbatis = RBatis::new();
                        rbatis.init(SqliteDriver {}, "db/rust_blog.db").unwrap();
                        Post::insert(&rbatis, &post)
                            .await
                            .expect("insert post failed!");
                    }
                }
            }
            Err(_) => {
                panic!("can't open dir");
            }
        }
    }
}
